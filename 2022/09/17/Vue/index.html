<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Vue | 云无月のBlog</title><meta name="keywords" content="Vue,手撕代码"><meta name="author" content="云无月"><meta name="copyright" content="云无月"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一级题目Vue基础Vue的基本原理1、建立虚拟DOM Tree，通过document.createDocumentFragment()，遍历指定根节点内部节点，根据、v-model等规则进行compile；2、通过Object.defineProperty()进行数据变化拦截；3、截取到的数据变化，通过发布者-订阅者模式，触发Watcher，从而改变虚拟DOM中的具体数据；4、通过改变虚拟DOM元">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue">
<meta property="og:url" content="https://zzrjack.github.io/2022/09/17/Vue/index.html">
<meta property="og:site_name" content="云无月のBlog">
<meta property="og:description" content="一级题目Vue基础Vue的基本原理1、建立虚拟DOM Tree，通过document.createDocumentFragment()，遍历指定根节点内部节点，根据、v-model等规则进行compile；2、通过Object.defineProperty()进行数据变化拦截；3、截取到的数据变化，通过发布者-订阅者模式，触发Watcher，从而改变虚拟DOM中的具体数据；4、通过改变虚拟DOM元">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zzrjack.github.io/img/bg1.jpg">
<meta property="article:published_time" content="2022-09-17T03:45:42.000Z">
<meta property="article:modified_time" content="2022-09-17T04:21:07.076Z">
<meta property="article:author" content="云无月">
<meta property="article:tag" content="Vue">
<meta property="article:tag" content="手撕代码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zzrjack.github.io/img/bg1.jpg"><link rel="shortcut icon" href="/img/ku.png"><link rel="canonical" href="https://zzrjack.github.io/2022/09/17/Vue/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vue',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-17 12:21:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/mouse.css" media="defer"><link rel="stylesheet" href="https://gcore.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macWhite.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E5%8D%97%E5%AE%AB.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/Message/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/bg1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">云无月のBlog</a></span><div id="he-plugin-simple"></div><div id="none_space"></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/Message/"><i class="fa-fw fas fa-comment"></i><span> 留言</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Vue</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-17T03:45:42.000Z" title="发表于 2022-09-17 11:45:42">2022-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-17T04:21:07.076Z" title="更新于 2022-09-17 12:21:07">2022-09-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Vue"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一级题目"><a href="#一级题目" class="headerlink" title="一级题目"></a>一级题目</h1><h2 id="Vue基础"><a href="#Vue基础" class="headerlink" title="Vue基础"></a>Vue基础</h2><h3 id="Vue的基本原理"><a href="#Vue的基本原理" class="headerlink" title="Vue的基本原理"></a>Vue的基本原理</h3><p>1、建立虚拟DOM Tree，通过document.createDocumentFragment()，遍历指定根节点内部节点，根据、v-model等规则进行compile；<br>2、通过Object.defineProperty()进行数据变化拦截；<br>3、截取到的数据变化，通过发布者-订阅者模式，触发Watcher，从而改变虚拟DOM中的具体数据；<br>4、通过改变虚拟DOM元素值，从而改变最后渲染dom树的值，完成双向绑定</p>
<p>完成数据的双向绑定在于Object.defineProperty()</p>
<h3 id="双向数据绑定的原理"><a href="#双向数据绑定的原理" class="headerlink" title="双向数据绑定的原理"></a>双向数据绑定的原理</h3><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。<br><strong>语法：</strong>Object.defineProperty(obj, prop, descriptor)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,<span class="string">&#x27;hello&#x27;</span>,&#123;</span><br><span class="line">  <span class="attr">get</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//我们在这里拦截到了数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get方法被调用&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>:<span class="keyword">function</span>(<span class="params">newValue</span>)&#123;</span><br><span class="line">    <span class="comment">//改变数据的值，拦截下来额</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;set方法被调用&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.<span class="property">hello</span><span class="comment">//输出为“get方法被调用”，输出了值。</span></span><br><span class="line">obj.<span class="property">hello</span> = <span class="string">&#x27;new Hello&#x27;</span>;<span class="comment">//输出为set方法被调用，修改了新值</span></span><br></pre></td></tr></table></figure>

<p>通过以上方法可以看出，获取对象属性值触发get、设置对象属性值触发set，因此我们可以想象到数据模型对象的属性设置和读取可以驱动view层的数据变化，view的数据变化传递给数据模型对象，在set里面可以做很多事情。</p>
<p>在这基础上，我们可以做到数据的双向绑定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newValue</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发setter&#x27;</span>);</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.text-box&#x27;</span>).<span class="property">innerHTML</span> = newValue;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.inp-text&#x27;</span>).<span class="property">value</span> = newValue;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触发getter&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.inp-text&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    obj.<span class="property">name</span> = e.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>



<h3 id="MVVM，MVC-MVP的区别"><a href="#MVVM，MVC-MVP的区别" class="headerlink" title="MVVM，MVC,MVP的区别"></a>MVVM，MVC,MVP的区别</h3><p>MVC:</p>
<p>MVC是Model-View-Controller的缩写，它将应用程序划分为三个部分：</p>
<p>Model: 模型（用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法）</p>
<p>View: 视图（渲染页面）</p>
<p>Controller: 控制器（M和V之间的连接器，用于控制应用程序的流程，及页面的业务逻辑）</p>
<p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p>
<img src="/2022/09/17/Vue/20171030143453496.png" class="">

<p>MVP:</p>
<p>MVP（Model-View-Presenter）是MVC的改良模式，由IBM的子公司Taligent提出。和MVC的相同之处在于：Controller&#x2F;Presenter负责业务逻辑，Model管理数据，View负责显示只不过是将 Controller 改名为 Presenter，同时改变了通信方向。</p>
<p>MVP特点：</p>
<p>M、V、P之间双向通信。<br>View 与 Model 不通信，都通过 Presenter 传递。Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。<br>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。<br>Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。不仅如此，还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试–从而不需要使用自动化的测试工具。<br>与MVC区别：</p>
<img src="/2022/09/17/Vue/20171030150432808.png" class="">

<hr>
<p>MVVM:</p>
<p>MVVM是Model-View-ViewModel的简写。微软的WPF(Windows Presentation Foundation–微软推出的基于Windows 的用户界面框架)带来了新的技术体验, 使得软件UI层更加细节化、可定制化。与此同时，在技术层面，WPF也带来了 诸如Binding（绑定）、Dependency Property（依赖属性）、Routed Events（路由事件）、Command（命令）、DataTemplate（数据模板）、ControlTemplate（控制模板）等新特性。MVVM模式其实是MV模式与WPF结合的应用方式时发展演变过来的一种新型架构模式。它立足于原有MVP框架并且把WPF的新特性糅合进去，以应对客户日益复杂的需求变化。</p>
<img src="/2022/09/17/Vue/20171030153807325.png" class="">

<p>低耦合，视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p>
<p>可重用性，可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</p>
<p>独立开发，开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。</p>
<p>可测试，界面向来是比较难于测试的，而现在测试可以针对ViewModel来写。</p>
<h3 id="Computed和watch的区别"><a href="#Computed和watch的区别" class="headerlink" title="Computed和watch的区别"></a>Computed和watch的区别</h3><p>计算属性computed :<br>1、支持缓存，只有依赖数据发生改变，才会重新进行计算<br>2、不支持异步，当computed内有异步操作时无效，无法监听数据的变化<br>3、computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值<br>4、如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed<br>5、如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p>
<hr>
<p>侦听属性watch：<br>1、不支持缓存，数据变，直接会触发相应的操作；<br>2、watch支持异步；<br>3、监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；<br>4、当一个属性发生变化时，需要执行对应的操作；一对多；<br>5、监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数： 　　<br>immediate：组件加载立即触发回调函数执行， 　　<br>deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</p>
<p>当需要在数据变化时执行异步或开销较大的操作时，一般用watch属性。</p>
<h3 id="Computed和Methods区别"><a href="#Computed和Methods区别" class="headerlink" title="Computed和Methods区别"></a>Computed和Methods区别</h3><p>1.computed是响应式的，methods并非响应式。<br>2.调用方式不一样，computed定义的成员像属性一样访问，methods定义的成员必须以函数形式调用。<br>3.computed是带缓存的，只有其引用的响应式属性发生改变时才会重新计算，而methods里的函数在每次调用时都要执行。<br>4.computed中的成员可以只定义一个函数作为只读属性，也可以定义get&#x2F;set变成可读写属性，这点是methods中的成员做不到的</p>
<p>在我们的实际开发中，有时很难去确定具体用computed还是methods，因为这两种方法最后的到的结果是一样的，但是他们的原理和用法却完全不同，比如：我们想去时刻监控数据的变化，在视图上显示不同的结果，当然这两中方法都可以实现这种效果，这个时候用computed就比较合理了，因为computed是可缓存的，只要数据层值不改变，computed就不会去改变，而且可缓存，如果数据层的值变了，computed就会实时更新到视图层上，所以说computed是响应式的。</p>
<p>还有一个不同点就是在于computed是以对象的属性方式存在的，在视图层直接调用就可以得到值，例如：<br><code>&#123;&#123;msg&#125;&#125;</code><br>而methods必须以函数形式调用，例如：<br><code>&#123;&#123;msg()&#125;&#125;</code><br>可见，computed直接以对象属性方式调用，而methods必须要函数执行才可以得到结果。</p>
<h3 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h3><p>1.v-show<br>v-show指令的作用是：根据真假值切换元素的显示状态,是响应式的<br>语法表达v-show &#x3D; “ 表达式 “<br>原理是修改元素的的CSS属性(display)来决定实现显示还是隐藏<br>指令后面的内容最终都会解析为布尔值<br>值为真(true)的时候元素显示，值为假(false)的时候元素隐藏</p>
<p>数据改变之后呢对应的元素的显示状态也是会同步更新的</p>
<p>2.v-if</p>
<ul>
<li>v-if指令的作用：根据表达式的真假切换元素的显示状态</li>
<li>v-if &#x3D; “表达式”</li>
<li>本质是通过操纵dom元素来进行切换显示</li>
<li>表达式的值为true的时候元素存在于dom树中，为false的时候从dom树中移除</li>
</ul>
<h3 id="data为什么是一个函数而不是一个对象"><a href="#data为什么是一个函数而不是一个对象" class="headerlink" title="data为什么是一个函数而不是一个对象"></a>data为什么是一个函数而不是一个对象</h3><p>vue的data数据其实是vue原型上的属性，数据存在于内存当中。vue为了保证每个实例上的data数据的独立性，规定了必须使用函数，而不是对象。</p>
<p>因为使用对象的话，每个实例（组件）上使用的data数据是相互影响的，这当然就不是我们想要的了。对象是对于内存地址的引用，直接定义个对象的话组件之间都会使用这个对象，这样会造成组件之间数据相互影响。</p>
<h3 id="Vue单页应用和多页应用的区别"><a href="#Vue单页应用和多页应用的区别" class="headerlink" title="Vue单页应用和多页应用的区别"></a>Vue单页应用和多页应用的区别</h3><p>一、Vue单页应用是什么？<br>就理解它为一个页面的应用，它自己和自己跳着玩，也不请求别的页面。感兴趣的可以看看调试工具里的Doc加载页面情况~</p>
<p>内部原理：<br>js做识别，判断路由发生变化。一旦路由变化js会销毁当前页面并替换新页面。</p>
<p>二、Vue多页应用是什么？<br>每个页面与每个页面都是独立的。每加载一个页面，就得发次请求。</p>
<p>内部原理：<br>页面每次请求都会向后端拿一次数据，每次都会生成一个html页面。仍然是在调试工具Doc里体现。</p>
<p>三、它俩有啥区别？<br>1、多页应用依赖后端，单页应用是前端实现。<br>2、性能方面来说，多页应用首屏加载较快，SEO搜索效果好。但缺点是切换页面相对较慢。这从原理上想的话也能理解，每次切换都要发请求，肯定相对慢一些。 单页应用则切换速度较快，但首屏加载较慢，SEO效果较差。从SEO来讲的话，因为SEO搜索时只能识别html，并不认识js，</p>
<p>四、总结<br>个人理解为就是多页就是每次跳转需要请求一次，单页不需要请求直接靠js识别进行跳转。多页需要后台支持，单页纯前台自己实现。多页还是相比于单页较为复杂。多页or单页，只是一种方案，适合自己的项目才是最好的。最后欢迎大家补充与修正~</p>
<hr>
<h3 id="Vue的优点"><a href="#Vue的优点" class="headerlink" title="Vue的优点"></a>Vue的优点</h3><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；</p>
<p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p>
<p>双向数据绑定：保留了angular的特点，在数据操作方面更为简单；</p>
<p>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；</p>
<p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p>
<p>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；</p>
<p>运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。</p>
<h3 id="对spa单页面的理解，它的优缺点分别是什么"><a href="#对spa单页面的理解，它的优缺点分别是什么" class="headerlink" title="对spa单页面的理解，它的优缺点分别是什么"></a>对spa单页面的理解，它的优缺点分别是什么</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p>优点：</p>
<p>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；<br>基于上面一点，SPA 相对对服务器压力小；<br>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；<br>缺点：</p>
<p>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；<br>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</p>
<p>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="简单说下vue的生命周期"><a href="#简单说下vue的生命周期" class="headerlink" title="简单说下vue的生命周期"></a>简单说下vue的生命周期</h3><p>beforeCreate（创建前）,</p>
<p>created（创建后）,</p>
<p>beforeMount(载入前),</p>
<p>mounted（载入后）,</p>
<p>beforeUpdate（更新前）,</p>
<p>updated（更新后）,</p>
<p>beforeDestroy（销毁前）,</p>
<p>destroyed（销毁后）</p>
<p>eg:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> myVue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">a</span>: <span class="string">&#x27;Vue.js&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">beforeCreate</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建前&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">created</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;创建之后&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">beforeMount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mount之前&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">mounted</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mount之后&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">beforeUpdate</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新前&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">updated</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;更新完成&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">beforeDestroy</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;销毁前&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">destroyed</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;已销毁&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">$el</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<img src="/2022/09/17/Vue/20170303180741807.png" class="">

<h3 id="created和mounted区别"><a href="#created和mounted区别" class="headerlink" title="created和mounted区别"></a>created和mounted区别</h3><p>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</p>
<p>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</p>
<p>通常created使用的次数多，而mounted通常是在一些插件的使用或者组件的使用中进行操作，比如插件chart.js的使用: var ctx &#x3D; document.getElementById(ID);通常会有这一步，而如果你写入组件中，你会发现在created中无法对chart进行一些初始化配置，一定要等这个html渲染完后才可以进行，那么mounted就是不二之选。</p>
<h3 id="一般在哪个生命周期请求异步数据"><a href="#一般在哪个生命周期请求异步数据" class="headerlink" title="一般在哪个生命周期请求异步数据"></a>一般在哪个生命周期请求异步数据</h3><p>created中调用异步请求最佳，用户就越早感知页面的已加载，越早获取数据，在mounted实例挂载的时候就越及时。</p>
<h3 id="keep-alive与生命周期"><a href="#keep-alive与生命周期" class="headerlink" title="keep-alive与生命周期"></a>keep-alive与生命周期</h3><p>1.keep-alive的生命周期<br>当引入keep-alive的时候，页面第一次进入，钩子的触发顺序created-&gt; mounted-&gt; activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。</p>
<p>2.基本用法<br>可以将 是否包裹 keep-alive 通过参数配置； </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=&quot;cachedViews&quot;&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>



<p>&#x2F;&#x2F;不需要刷新的路由配置里面配置 meta: {keepAlive: true}, 这个路由则显示在上面标签；<br>&#x2F;&#x2F;需要刷新的路由配置里面配置 meta: {keepAlive: false}, 这个路由则显示在下面标签；<br>3.作用<br>返回dom不让其重新刷新，在vue-view外面包一层, 当引入keep-alive的时候，页面第一次进入，钩子的触发顺序created-&gt; mounted-&gt; activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。</p>
<p> 事件挂载的方法等，只执行一次的放在 mounted 中；组件每次进去执行的方法放在 activated 中； </p>
<p>4.指定刷新<br>在keep-alive中直接添加 include，cachedViews（Array类型：包含vue文件的组件name都将被缓存起来）；反之exclude则是不包含；</p>
<p>注意：所有.vue组件文件都必须附上name属性！！！建议用vuex管理cachedViews</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive :include=&quot;cachedViews&quot;&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>

<p><strong>生命周期函数：就是vue在某个时间段会自动执行的函数</strong><br>1.beforeCreate(){}在执行的时候，data还有methods都没有被初始化</p>
<p>2.created(){} data还有methods都被初始化好了，如果要调用methods方法或者操作data里面的数据，最早只能在created里面进行操作。</p>
<p>3.beforeMount(){} 表示模板已经在内存中编辑完成了，但是尚未渲染到模板页面中。即页面中的元素，没有被真正的替换过来，只是之前写的一些模板字符串。</p>
<p>4.mounted(){} 表示内存中模板已经真实的挂载到页面中去了，用户可以看到渲染好的界面了</p>
<p>   注意这是一个生命周期函数的最后一个函数了，执行完这个函数表示 整个vue实例已经初始化完成了，组件脱离了创建阶段，进入运行阶段。</p>
<p>下面是运行期间的两个生命周期函数的钩子：</p>
<p>5.beforeUpdate(){}  表示我们的界面还没更新 但是data里面的数据是最新的。即页面尚未和最新的data里面的数据包吃同步。</p>
<p>6.update(){} 表示页面和data里面的数据已经包吃同步了 都是最新的。</p>
<p>7.beforeDestory(){}  当执行这个生命周期钩子的时候 vue的实例从运行阶段进入销毁阶段 此时实例身上的data 还有 methods处于可用的状态。</p>
<p>8.Destoryed(){} 表示组件已经完全被销毁了 组件中所有的实例方法都是不能用了</p>
<h2 id="组件通信的方式有哪些"><a href="#组件通信的方式有哪些" class="headerlink" title="组件通信的方式有哪些"></a>组件通信的方式有哪些</h2><p>1、props：用于父&#x3D;》子组件通信: </p>
<p><strong>注：prop 只可以从<code>上一级</code>组件传递到<code>下一级</code>组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告</strong>。</p>
<p>父组件通过props的方式向子组件传递数据，而子组件通过$emit 可以向父组件通信。<br>举例：子组件的props选项能够接收来自父组件数据。没错，仅仅只能接收，props是单向绑定的，即只能父组件向子组件传递，不能反向。而传递的方式也分为两种：</p>
<p>①静态：子组件通过props选项来声明一个自定义的属性，然后父组件就可以在嵌套标签的时候，通过这个属性往子组件传递数据了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line"> &lt;h1&gt;我是父组件！&lt;/h1&gt;</span><br><span class="line"> &lt;child message=&quot;我是子组件一！&quot;&gt;&lt;/child&gt; //通过自定义属性传递数据</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#x27;../components/child.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line"> components: &#123;Child&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line"> </span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line"> props: [&#x27;message&#x27;] //声明一个自定义的属性</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>②动态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- 父组件 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line"> &lt;h1&gt;我是父组件！&lt;/h1&gt;</span><br><span class="line"> &lt;child message=&quot;我是子组件一！&quot;&gt;&lt;/child&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span><br><span class="line"> &lt;child v-bind:message=&quot;a+b&quot;&gt;&lt;/child&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 用一个变量进行动态赋值。--&gt;</span><br><span class="line"> &lt;child v-bind:message=&quot;msg&quot;&gt;&lt;/child&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#x27;../components/child.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line"> components: &#123;Child&#125;,</span><br><span class="line"> data() &#123;</span><br><span class="line"> return &#123;</span><br><span class="line">  a:&#x27;我是子组件二！&#x27;,</span><br><span class="line">  b:112233,</span><br><span class="line">  msg: &#x27;我是子组件三！&#x27;+ Math.random()</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!-- 子组件 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;h3&gt;&#123;&#123;message&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line"> props: [&#x27;message&#x27;]</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、<strong>自定义事件</strong>：@on，@emit 可以实现子给父通信即<code>vm.$emit( event, arg )</code></p>
<ul>
<li>$emit绑定一个自定义事件event，当这个这个语句被执行到的时候，就会将参数arg传递给父组件，父组件通过@event监听并接收参数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line"> &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;</span><br><span class="line"> &lt;child @getMessage=&quot;showMsg&quot;&gt;&lt;/child&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"> import Child from &#x27;../components/child.vue&#x27;</span><br><span class="line"> export default &#123;</span><br><span class="line"> components: &#123;Child&#125;,</span><br><span class="line"> data()&#123;</span><br><span class="line">  return&#123;</span><br><span class="line">  title:&#x27;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> methods:&#123;</span><br><span class="line">  showMsg(title)&#123;</span><br><span class="line">  this.title=title;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;h3&gt;我是子组件！&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line"> mounted: function () &#123;</span><br><span class="line">  this.$emit(&#x27;getMessage&#x27;, &#x27;我是父组件！&#x27;)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.<strong>插槽</strong></p>
<ul>
<li>插槽就是子组件中的提供给父组件使用的一个占位符，用<code>&lt;slot&gt;&lt;/slot&gt;</code> 表示，父组件可以在这个占位符中填充任何模板代码，如 HTML、组件等，填充的内容会替换子组件的<code>&lt;slot&gt;&lt;/slot&gt;</code>标签。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;今天天气状况：&lt;/h1&gt;</span><br><span class="line">        &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &#x27;child&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;使用slot分发内容&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;child&gt;</span><br><span class="line">                &lt;div style=&quot;margin-top: 30px&quot;&gt;多云，最高气温34度，最低气温28度，微风&lt;/div&gt;</span><br><span class="line">            &lt;/child&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import child from &quot;./child.vue&quot;;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &#x27;father&#x27;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>4.<strong>全局事件总线eventBus</strong>：$bus 全能</p>
<ul>
<li>对于比较小型的项目，没有必要引入 vuex 的情况下，可以使用 eventBus。</li>
<li>它的实现思想也很好理解，在要相互通信的两个组件中，都引入同一个新的vue实例，然后在两个组件中通过分别调用这个实例的事件触发和监听来实现通信。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//eventBus.js</span><br><span class="line">import Vue from &#x27;vue&#x27;;</span><br><span class="line">export default new Vue();</span><br><span class="line">&lt;!--组件A--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Bus from &#x27;eventBus.js&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        sayHello() &#123;</span><br><span class="line">            Bus.$emit(&#x27;sayHello&#x27;, &#x27;hello&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!--组件B--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Bus from &#x27;eventBus.js&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        Bus.$on(&#x27;sayHello&#x27;, target =&gt; &#123;</span><br><span class="line">            console.log(target);  // =&gt; &#x27;hello&#x27;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>5.<strong>Vuex 核心</strong></p>
<p>State：保存所有组件的共享状态<br>Getters：类似状态值的计算属性<br>Mutations：修改 State中状态值的唯一方法，里面包含状态变化监听器和记录器<br>Actions：用于异步处理 State中状态值，异步函数结束后调用Mutations<br>Modules：当一个 State 对象比较庞大时，可以将 State 分割成多个Modules 模块。</p>
<p><strong>总结</strong><br>1.可以实现任意组件的通信的方法有两个：事件总线 和 Vuex，事件总线难维护数据但轻量，Vux维护数据方便但比较重量。<br>2.可以实现父与子孙跨越层级通信的方法也有两个：$attrs&#x2F;$listeners 和 provide&#x2F;inject ，$attrs&#x2F;​$listeners 具有响应性且可以双向通信， provide&#x2F;inject 无响应性且只能单向通信（父传子）<br>3.只能实现父与子组件通信的方法有一个：props&#x2F;emit，方法比较基础，适合只有父子组件通信的方法，若想跨层级通信需要中间组件做转发，比较麻烦。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="hash和history模式的区别"><a href="#hash和history模式的区别" class="headerlink" title="hash和history模式的区别"></a>hash和history模式的区别</h3><p>1、 history和hash都是利用浏览器的两种特性实现前端路由，history是利用浏览历史记录栈的API实现，hash是监听location对象hash值变化事件来实现</p>
<p>2、 history的url没有’#’号，hash反之</p>
<p>3、 相同的url，history会触发添加到浏览器历史记录栈中，hash不会触发，history需要后端配合，如果后端不配合刷新新页面会出现404，hash不需要</p>
<p>4、<br>HashRouter的原理：通过window.onhashchange方法获取新URL中hash值，再做进一步处理 HistoryRouter的原理：通过history.pushState 使用它做页面跳转不会触发页面刷新，使用window.onpopstate 监听浏览器的前进和后退，再做其他处理</p>
<h3 id="对前端路由的理解"><a href="#对前端路由的理解" class="headerlink" title="对前端路由的理解"></a>对前端路由的理解</h3><p>一、路由（route）<br>定义<br>路由是url到函数的映射，可以根据不同的url地址展示不同的内容或页面。</p>
<p>&#x2F;users        -&gt;  getAllUsers()<br>&#x2F;users&#x2F;count  -&gt;  getUsersCount()</p>
<p>这就是两条路由，当访问 &#x2F;users 的时候，会执行 getAllUsers() 函数；当访问 &#x2F;users&#x2F;count 的时候，会执行 getUsersCount() 函数。</p>
<p>router<br>是一个容器，或机制，管理了一组route。简单来说，route 只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由 router 来处理的。一句话概括就是 “The router routes you to a route”。</p>
<p>二、服务器端路由（后端路由）<br>对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。对于最简单的静态资源服务器，可以认为，所有URL的映射函数就是一个文件读取操作。对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据的处理，等等。</p>
<p>在 router 匹配 route 的过程中，不仅会根据URL来匹配，还会根据请求的方法来看是否匹配。例如上面的例子，如果通过 POST 方法来访问 &#x2F;users，就会找不到正确的路由。</p>
<p>早期的路由都是后端实现的，直接根据 url 来 reload 页面，页面变得越来越复杂服务器端压力变大，随着 ajax 的出现，页面实现非 reload 就能刷新数据，可以通过记录 url 来记录 ajax 的变化，从而实现前端路由。</p>
<p>三、客户端路由（前端路由）<br>对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案。</p>
<p>基于history API<br>在 HTML5 规范中，history 新增了以下几个 API，能做到：改变 url 的同时，不会刷新页面。</p>
<p>history.pushState();         &#x2F;&#x2F; 添加新的状态到历史状态栈<br>history.replaceState();     &#x2F;&#x2F; 用新的状态代替当前状态</p>
<p>接收三个参数，分别是：</p>
<p>状态对象（state object） — 一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。<br>标题（title） — FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。<br>地址（URL） — 新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。<br>基于hash<br>url上的hash本来是锚点（#），方便用户在很长的文档中进行上下文导航，且hash有一种特性：改变url的同时不刷新页面，浏览器用onhashchange事件监听hash的变化。</p>
<p>优缺点<br>hash路由兼容性更好，不需对服务器做改动<br>history API更直观和正式，需要对服务器进行改造<br>四、动态路由</p>
<p>静态路由是路径固定的路由，但是有时候需要在路径中传入参数，例如获取某个用户的信息，不可能为每个用户创建路由，而是通过捕获路径中的参数（例如用户id）来实现，这就是动态路由。</p>
<h3 id="如何获取页面hash的变化"><a href="#如何获取页面hash的变化" class="headerlink" title="如何获取页面hash的变化"></a>如何获取页面hash的变化</h3><p>1.获取hash值<br>location.hash：hash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分）</p>
<p>2.获取路径值<br>location.pathname：pathname 属性是一个可读可写的字符串，可设置或返回当前 URL 的路径部分</p>
<p>3.监听hash值变化<br>使用hashchange方法监听</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前的hash值发生了变化&#x27;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        slice(start,end):切片，返回新数组</span></span><br><span class="line"><span class="comment">            start——必需。规定从何处开始选取。</span></span><br><span class="line"><span class="comment">            end——可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">let</span> currentHash = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(currentHash ); <span class="comment">//打印hash值</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>4.监听路径值变化<br>写个onclick方法，监听路径值的变化</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">&quot;changeUrl(&#x27;/home&#x27;)&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">&quot;changeUrl(&#x27;/help&#x27;)&quot;</span>&gt;</span>帮助<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">changeUrl</span>(<span class="params">path</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        pushState:</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            参数一：对象，可以传空</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            参数二：追加完路径后，当前网页的标题，会被浏览器忽略</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            参数三：追加的路径</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        * */</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 将路径追加到url后面</span></span></span><br><span class="line"><span class="language-javascript">        history.<span class="title function_">pushState</span>(<span class="literal">null</span>, <span class="literal">null</span>, path)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="route-router的区别"><a href="#route-router的区别" class="headerlink" title="$route $router的区别"></a>$route $router的区别</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$router : 是路由操作对象，只写对象</span></span><br><span class="line"><span class="comment">//$route : 路由信息对象，只读对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作 路由跳转</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">`argu`</span>,</span><br><span class="line">      <span class="attr">params</span>:&#123;</span><br><span class="line">          <span class="attr">name</span>:<span class="string">&#x27;xrw&#x27;</span>,</span><br><span class="line">          <span class="attr">age</span>:<span class="string">&#x27;123&#x27;</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取 路由参数接收</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">age</span> = <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">age</span>;</span><br></pre></td></tr></table></figure>



<p>1.$router是VueRouter的一个对象，通过Vue.use(VueRouter)和Vu<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">构造函数</a>得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由，包含了许多关键的对象和属性。</p>
<p>以history对象来举例：</p>
<p>$router.push({path:’home’})，本质是向history栈中添加一个路由，在我们看来是切换路由，但本质是在添加一个history记录</p>
<p>$router.replace({path:’home’})，&#x2F;&#x2F;替换路由，没有历史记录</p>
<p>2.$route是一个跳转的路由对象，每一个路由都会有一个$route对象，是一个局部的对象，可以获取对应的name，path，params，query等</p>
<p>$route.path 字符串，等于当前路由对象的路径，会被解析为绝对路径，如&#x2F;home&#x2F;ews</p>
<p>$route.params 对象，含路有种的动态片段和全匹配片段的键值对，不会拼接到路由的url后面</p>
<p>$route.query 对象，包含路由中查询参数的键值对。会拼接到路由url后面</p>
<p>$route.router 路由规则所属的路由器</p>
<p>$route.matchd 数组，包含当前匹配的路径中所包含的所有片段所对象的配置参数对象</p>
<p>$route.name 当前路由的名字，如果没有使用具体路径，则名字为空</p>
<h3 id="params和query的区别"><a href="#params和query的区别" class="headerlink" title="params和query的区别"></a>params和query的区别</h3><p>query传递参数会在url后面用？连接起来，且参数之间用&amp;&amp;符号连接然后显示在页面的url中；params传递参数不会显示在页面中；query有点像ajax中的get请求，而params像post请求。</p>
<p>在vue中使用query要搭配path路径，而params只能由命名路由name来引入；看下列代码：</p>
<p>路由中path的配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">		<span class="attr">path</span>: <span class="string">&#x27;/argu/:name/:id&#x27;</span>, <span class="comment">//这种路由配置是params传递参数,且这个后面必须加参数，如果不加，刷新页面这些参数会消失</span></span><br><span class="line">		<span class="attr">name</span>:<span class="string">&#x27;argu&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/argu.vue&#x27;</span>),</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>

<p>使用params传递参数注意要在path路径后面添加参数，不然刷新页面数据会丢失。</p>
<p>使用params传参的具体写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">    				<span class="comment">//params要name一起用，不然接收不到参数</span></span><br><span class="line">					<span class="attr">name</span>: <span class="string">`argu`</span>,</span><br><span class="line">					<span class="attr">params</span>:&#123;</span><br><span class="line">						<span class="attr">name</span>:<span class="string">&#x27;xrw&#x27;</span>,</span><br><span class="line">                        <span class="attr">id</span>:<span class="string">&#x27;123&#x27;</span></span><br><span class="line">					&#125;	</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>使用query传递参数，在路由中设置path: ‘&#x2F;argu’，后面可以不跟参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; </span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/argu&#x27;</span>, </span><br><span class="line">    <span class="comment">//如果在路由中配置了name属性在这里也是可以用的 name:&#x27;argu&#x27; 效果同上</span></span><br><span class="line">    <span class="attr">query</span>:&#123; </span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;xrw&#x27;</span></span><br><span class="line">        id : <span class="string">&#x27;123&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)	</span><br></pre></td></tr></table></figure>

<p>两者接收参数的形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//query：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//query接收参数</span></span><br><span class="line">&#123;&#123; <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">name</span> &#125;&#125;</span><br><span class="line">&#123;&#123; <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">id</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//params:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//params接受参数</span></span><br><span class="line">&#123;&#123; <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">name</span> &#125;&#125;</span><br><span class="line">&#123;&#123; <span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">id</span> &#125;&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>组件中也可以用props来进行接受参数，这种方式（推荐方法）</p>
<p>这样需要在路由配置中设置props为true:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">		<span class="attr">path</span>: <span class="string">&#x27;/argu&#x27;</span>, </span><br><span class="line">		<span class="attr">name</span>:<span class="string">&#x27;argu&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/argu.vue&#x27;</span>),</span><br><span class="line">		<span class="comment">//设置props为ture，代表将path后面的参数作为值，传递到组件中，组件中通过props属性接受这个值</span></span><br><span class="line">		<span class="attr">props</span>:<span class="literal">true</span>,</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>

<p>然后再组件中设置props来接收这个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">    //props形式传递参数</span><br><span class="line">	 &#123;&#123; name &#125;&#125;</span><br><span class="line">	 &#123;&#123; id &#125;&#125;</span><br><span class="line">	//$route形式传递参数</span><br><span class="line">	 &#123;&#123; this.$route.params.name &#125;&#125; </span><br><span class="line">	 &#123;&#123; this.$route.params.id &#125;&#125;</span><br><span class="line">	 &#123;&#123; this.$route.query.name &#125;&#125;</span><br><span class="line">	 &#123;&#123; this.$route.query.id &#125;&#125; </span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">	 props:&#123;</span><br><span class="line">		 name:&#123;</span><br><span class="line">			 type:String,</span><br><span class="line">			 default:&#x27;lily&#x27; //默认情况</span><br><span class="line">		 &#125;,</span><br><span class="line">		 id:&#123;</span><br><span class="line">			 type:Number,</span><br><span class="line">			 default:&#x27;0&#x27; //默认情况</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>总结<br>query和params是两种传参方式<br>使用params传参只能由name引入路由，如果写成path页面会显示undefined报错。<br>使用query传参的话可以使用path也可以使用name引入路由，不过建议使用path引入路由。<br>params是路由的一部分，一定要加路由后面添加参数，不添加刷新页面数据会丢失；而query是拼接在url后面的参数，路由后面不添加也没关系。</p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="Vuex的原理以及自己的理解"><a href="#Vuex的原理以及自己的理解" class="headerlink" title="Vuex的原理以及自己的理解"></a>Vuex的原理以及自己的理解</h3><p>Vuex是专门为Vue服务，用于管理页面的数据状态、提供统一数据操作的生态系统，相当于数据库mongoDB，MySQL等，任何组件都可以存取仓库中的数据。</p>
<p>Vuex采用MVC模式中的Model层，规定所有的数据必须通过action—&gt;mutaion—&gt;state这个流程进行来改变状态的。再结合Vue的数据视图双向绑定实现页面的更新。</p>
<p>vuex中也有四个属性值：state、getters、mutations、actions。。</p>
<p>在没有actions的情况下：</p>
<p>数据：state –&gt; data<br>获取数据：getters –&gt; computed<br>更改数据：mutations –&gt; methods<br>视图通过点击事件，触发mutations中方法，可以更改state中的数据，一旦state数据发生更改，getters把数据反映到视图。</p>
<p>那么actions,可以理解处理异步，而单纯多加的一层。</p>
<p>既然提到了mutions actions这时候 就不得不提commit，dispatch这两个有什么作用呢？</p>
<p>在vue例子中，通过click事件，触发methods中的方法。当存在异步时，而在vuex中需要dispatch来触发actions中的方法，actions中的commit可以触发mutations中的方法。同步，则直接在组件中commit触发vuex中mutations中的方法。</p>
<img src="/2022/09/17/Vue/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzIyLzE2ZDU3YTUxMDFhMGQ5MmY.png" class="">

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store =  <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//state的值只能通过mutations来修改</span></span><br><span class="line">    <span class="attr">mutations</span>: &#123;</span><br><span class="line">        <span class="title function_">increment</span>(<span class="params">state</span>) &#123;</span><br><span class="line">            state.<span class="property">count</span>++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//this.$store.commit(&quot;increment&quot;)触发mutations中函数&quot;increment&quot;</span></span><br><span class="line">    <span class="attr">actions</span>: &#123;</span><br><span class="line">        <span class="title function_">increment</span>(<span class="params">&#123;commit&#125;</span>) &#123;</span><br><span class="line">             <span class="title function_">commit</span>(<span class="string">&quot;increment&quot;</span>); <span class="comment">//this.$store.commit(&quot;increment&quot;)</span></span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//通过getter中的方法来获取state值</span></span><br><span class="line">    <span class="attr">getters</span>: &#123;</span><br><span class="line">        <span class="title function_">getCount</span>(<span class="params">state</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.<span class="property">count</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>App.vue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;button @click=&quot;increment&quot;&gt;增加&lt;/button&gt;</span><br><span class="line">        &lt;!-- 有时候不能直接 强制使用store里面的状态 this.$store.state.count --&gt;</span><br><span class="line">        &#123;&#123;this.$store.getters.getCount&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">    increment()&#123;</span><br><span class="line">            //this.$store.dispatch(&quot;increment&quot;)触发actions函数&quot;increment&quot;</span><br><span class="line">            this.$store.dispatch(&quot;increment&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="action和mutation的区别"><a href="#action和mutation的区别" class="headerlink" title="action和mutation的区别"></a>action和mutation的区别</h3><p>action中处理异步，mutation不可以<br>mutation做原子操作<br>action可以整合多个mutation的集合</p>
<p>mutation 是同步更新数据(内部会进行是否为异步方式更新数据的检测) $watch 严格模式下会报错<br>action 异步操作，可以获取数据后调佣 mutation 提交最终数据</p>
<p>基于流程顺序，二者扮演不同的角色。</p>
<p>Mutation：专注于修改State，理论上是修改State的唯一途径。</p>
<p>Action：业务代码、异步请求。</p>
<h3 id="Rudex和Vuex的区别，他们共同的思想"><a href="#Rudex和Vuex的区别，他们共同的思想" class="headerlink" title="Rudex和Vuex的区别，他们共同的思想"></a>Rudex和Vuex的区别，他们共同的思想</h3><p>1.表面区别就是vuex是通过将store注入到组件实例中，通过dispatch和commit来维护state的状态，并可以通过mapstate和this.$store来读取state数据。而redux则是需要通过connect将state和dispatch链接来映射state并操作state。redux没有commit，直接通过dispatch派发一个action来维护state的数据。并且只能通过reducer一个函数来操作state。<br>2.rudex使用的是不可变数据；vuex是可变的数据。<br>3.rudex每次都是返回一个新的state；而vuex是直接改变state。</p>
<hr>
<p>共同思想：<br>1)全局只有一个Store实例(单一数据源)</p>
<p>2)vuex改变状态的机制也是大同小异，vuex中的mutation和reducer一样，所有的状态的改变都应该在mutation中执行</p>
<h2 id="Vue3-0"><a href="#Vue3-0" class="headerlink" title="Vue3.0"></a>Vue3.0</h2><h3 id="有什么更新"><a href="#有什么更新" class="headerlink" title="有什么更新"></a>有什么更新</h3><p><strong>vue2和vue3双向数据绑定原理发生了改变</strong><br>vue2 的双向数据绑定是利用ES5 的一个 API Object.definePropert()对数据进行劫持 结合 发布订阅模式的方式来实现的。</p>
<p>vue3 中使用了 es6 的 ProxyAPI 对数据代理。</p>
<p>相比于vue2.x，使用proxy的优势如下</p>
<p>defineProperty只能监听某个属性，不能对全对象监听<br>可以省去for in、闭包等内容来提升效率（直接绑定整个对象即可）<br>可以监听数组，不用再去单独的对数组做特异性操作 vue3.x可以检测到数组内部数据的变化</p>
<p><strong>2.Vue3支持碎片(Fragments)</strong></p>
<p>就是说在组件可以拥有多个根节点。</p>
<p><strong>3.Composition API</strong><br>Vue2与Vue3 最大的区别 — Vue2使用选项类型API（Options API）对比Vue3合成型API（Composition API）</p>
<p>旧的选项型API在代码里分割了不同的属性: data,computed属性，methods，等等。新的合成型API能让我们用方法（function）来分割，相比于旧的API使用属性来分组，这样代码会更加简便和整洁。</p>
<p><strong>4.setup()</strong></p>
<p>Vue2 - 把数据放入data属性中</p>
<p>在Vue3.0，我们就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。</p>
<p>使用以下三步来建立反应性数据:</p>
<p>从vue引入reactive<br>使用reactive()方法来声名我们的数据为响应性数据<br>使用setup()方法来返回我们的响应性数据，从而我们的template可以获取这些响应性数据</p>
<p><strong>5.全新生命周期钩子</strong></p>
<p>setup() :开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method<br>onBeforeMount() : 组件挂载到节点上之前执行的函数。<br>onMounted() : 组件挂载完成后执行的函数。<br>onBeforeUpdate(): 组件更新之前执行的函数。<br>onUpdated(): 组件更新完成之后执行的函数。<br>onBeforeUnmount(): 组件卸载之前执行的函数。<br>onUnmounted(): 组件卸载完成后执行的函数<br>若组件被<keep-alive>包含，则多出下面两个钩子函数。<br>onActivated(): 被包含在中的组件，会多出两个生命周期钩子函数。被激活时执行 。<br>onDeactivated(): 比如从 A组件，切换到 B 组件，A 组件消失时执行。</p>
<p><strong>6.父子传参不同，setup() 函数特性</strong><br>总结：<br>1、setup 函数时，它将接受两个参数：（props、context(包含attrs、slots、emit)）</p>
<p>2、setup函数是处于 生命周期函数 beforeCreate 和 Created 两个钩子函数之前的函数</p>
<p>3、执行 setup 时，组件实例尚未被创建（在 setup() 内部，this 不会是该活跃实例的引用，即不指向vue实例，Vue 为了避免我们错误的使用，直接将 setup函数中的this修改成了 undefined）</p>
<p>4、与模板一起使用：需要返回一个对象 (在setup函数中定义的变量和方法最后都是需要 return 出去的 不然无法再模板中使用)</p>
<p>5、使用渲染函数：可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态</p>
<p>注意事项：</p>
<p>1、setup函数中不能使用this。Vue 为了避免我们错误的使用，直接将 setup函数中的this修改成了 undefined）</p>
<p>2、setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。但是，因为 props 是响应式的，你不能使用 ES6 解构，因为它会消除 prop 的响应性。</p>
<p>如果需要解构 prop，可以通过使用 setup 函数中的toRefs 来完成此操作：</p>
<p><strong>7.vue3 Teleport瞬移组件</strong></p>
<p>Teleport 可以把modal组件渲染到任意你想渲染的外部Dom上,不必嵌套在#app中,这样就可以互不干扰了,可以把Teleport看成一个传送门,把你的组件传送到任何地方<br>使用的时候 to属性可以确定想要挂载的DOM节点下面</p>
<h3 id="defineProperty和proxy的区别"><a href="#defineProperty和proxy的区别" class="headerlink" title="defineProperty和proxy的区别"></a>defineProperty和proxy的区别</h3><p><strong>Object.defineProperty</strong><br>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。IE8不兼容。</p>
<p>Object.defineProperty(obj, prop, descriptor)</p>
<p>参数<br>obj: 要定义属性的对象。<br>prop: 要定义或修改的属性的名称或 Symbol 。<br>descriptor: 要定义或修改的属性描述符。</p>
<p>返回值<br>被传递给函数的对象。</p>
<p><strong>Proxy</strong><br>Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。IE不兼容。</p>
<p>const p &#x3D; new Proxy(target, handler)</p>
<p>参数<br>target: 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。<br>handler: 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</p>
<p>返回值<br>一个Proxy代理的对象，操作这个对象会触发handler对应操作。改变原始对象不会触发。</p>
<p>handler 对象的方法<br>handler 对象是一个容纳一批特定属性的占位符对象。它包含有 Proxy 的各个捕获器（trap）。</p>
<p>所有的捕捉器是可选的。如果没有定义某个捕捉器，那么就会保留源对象的默认行为。</p>
<p>区别：</p>
<p>1.Proxy代理整个对象，Object.defineProperty只代理对象上的某个属性。<br>2.vue中，Proxy在调用时递归，Object.defineProperty在一开始就全部递归，Proxy性能优于Object.defineProperty。<br>3.对象上定义新属性时，Proxy可以监听到，Object.defineProperty监听不到。<br>4.数组新增删除修改时，Proxy可以监听到，Object.defineProperty监听不到。<br>5.Proxy不兼容IE，Object.defineProperty不兼容IE8及以下。</p>
<p><strong>Object.defineProperty必须“预先”劫持属性。被劫持的属性才会被监听到。所以后添加的属性，需要手动再次劫持。</strong></p>
<p><strong>而proxy代理了整个对象，不需要预先劫持属性，而是在获取&#x2F;修改的时候，通过get&#x2F;set方法来告诉你key。所以不管如何新增属性，总是能被捕获到。</strong></p>
<h3 id="为什么3-0要用proxy"><a href="#为什么3-0要用proxy" class="headerlink" title="为什么3.0要用proxy"></a>为什么3.0要用proxy</h3><p>见上题区别</p>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><h3 id="对虚拟Dom的理解"><a href="#对虚拟Dom的理解" class="headerlink" title="对虚拟Dom的理解"></a>对虚拟Dom的理解</h3><p><strong>虚拟dom就是一个普通的js对象</strong>。是一个用来描述真实dom结构的js对象，因为他不是真实dom，所以才叫虚拟dom。</p>
<p><strong>虚拟dom的作用</strong><br>1、我们都知道，传统dom数据发送变化的时候，我们都需要不断的去操作dom，才能更新dom的数据，虽然后面出现了模板引擎这种东西，可以让我们一次性去更新多个dom。但模板引擎依旧没有一种可以追踪状态的机制，当引擎内某个数据发生变化时，他依然要操作dom去重新渲染整个引擎。<br>而虚拟dom可以很好的跟踪当前dom状态，因为他会根据当前数据生成一个描述当前dom结构的虚拟dom，然后数据发送变化时，又会生成一个新的虚拟dom，而这两个虚拟dom恰恰保存了变化前后的状态。然后通过diff算法，计算出两个前后两个虚拟dom之间的差异，得出一个更新的最优方法（哪些发生改变，就更新哪些）。可以很明显的提升渲染效率以及用户体验<br>2、因为虚拟dom是一个普通的javascript对象，故他不单单只能允许在浏览器端，渲染出来的虚拟dom可同时在node环境下或者weex的app环境下允许。有很好的跨端性</p>
<h3 id="DIFF算法的原理"><a href="#DIFF算法的原理" class="headerlink" title="DIFF算法的原理"></a>DIFF算法的原理</h3><p>diff算法将虚拟DOM的某个节点数据改变后生成新的的node节点与旧节点进行比较，并替换为新的节点，具体过程就是调用Patch方法，比较新旧节点，一边比较一边给真实DOM打补丁进行替换<br>简单来说，diff算法有以下过程<br><strong>1.同级比较，再比较子节点</strong><br>如果节点类型不同，直接干掉前面的节点，再创建并插入新节点，不会再比较这个节点以后的子节点。<br>（先判断一方有子节点一方 没有子节点的情况(如果新的children没有子节点，将旧的节点移除)）<br>比较都有子节点的情况(核心diff)<br><strong>2.递归比较子节点</strong><br>正常diff两个树的时间复杂度是O(n^3)， 但实际情况下我们很少会进行跨层级的移动DOM，所以vue将diff进行了优化，从O(n^3)–&gt;O(n)，只有当新旧children都为多个子节点时才需要用核心的diff算法进行同层级比较。<br>Vue2的核心diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助Key值找到可复用的节点，再进行相关操作。<br>新旧children中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的，需要在新旧children的节点中保存映射关系，以便能够在旧children的节点中找到可复用的节点。<strong>key也就是children中节点的唯一标识。</strong><br>相比React的diff算法，同样情况下可以减少移动节点的次数，减少不必要的性能损耗，更加的优雅。<br>Vue3.x借鉴了ivi算法和inferno算法<br>在创建VNode时就确定其类型，以及在mount&#x2F;patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升(实际的实现可以结合Vue3.x的源码看)<br>该算法中还运用了动态规划的思想求解最长递归子序列</p>
<h3 id="Vue中Key的作用"><a href="#Vue中Key的作用" class="headerlink" title="Vue中Key的作用"></a>Vue中Key的作用</h3><ul>
<li>key在Vue是DOM对象的标识；</li>
<li>进行列表展示时，默认key是index；</li>
<li>如果数据只做展示使用，使用index作为key是没有任何问题的；</li>
<li>如果使用index作为key，而后续操作会破坏顺序，一定会带来效率问题，严重时会渲染出错误的DOM</li>
</ul>
<h3 id="为什么不建议index作为Key"><a href="#为什么不建议index作为Key" class="headerlink" title="为什么不建议index作为Key"></a>为什么不建议index作为Key</h3><p>如果使用index作为key，而后续操作会破坏顺序，一定会带来效率问题，严重时会渲染出错误的DOM</p>
<p>修改为数据的唯一标识，则不会产生这样的问题。</p>
<h3 id="虚拟DOM真的比真实DOM性能好吗"><a href="#虚拟DOM真的比真实DOM性能好吗" class="headerlink" title="虚拟DOM真的比真实DOM性能好吗"></a>虚拟DOM真的比真实DOM性能好吗</h3><p>然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</p>
<h3 id="虚拟DOM解析过程"><a href="#虚拟DOM解析过程" class="headerlink" title="虚拟DOM解析过程"></a>虚拟DOM解析过程</h3><p>在vue中，每个组件都有一个<code>render</code>函数，每个<code>render</code>函数都会返回一个虚拟dom树，这也就意味着每个组件都对应一棵虚拟DOM树</p>
<p>在一个组件实例首次被渲染时，它先生成虚拟dom树，然后根据虚拟dom树创建真实dom，并把真实dom挂载到页面中合适的位置，此时，每个虚拟dom便会对应一个真实的dom。</p>
<p>如果一个组件受响应式数据变化的影响，需要重新渲染时，它仍然会重新调用render函数，创建出一个新的虚拟dom树，用新树和旧树对比（diff算法），通过对比，vue会找到最小更新量，然后更新必要的真实dom节点</p>
<p>这样一来，就保证了对真实dom达到最小的改动。</p>
<h1 id="二级题目"><a href="#二级题目" class="headerlink" title="二级题目"></a>二级题目</h1><h2 id="vue基础"><a href="#vue基础" class="headerlink" title="vue基础"></a>vue基础</h2><h3 id="使用Object-defineProperty-来进行数据劫持有什么缺点"><a href="#使用Object-defineProperty-来进行数据劫持有什么缺点" class="headerlink" title="使用Object.defineProperty()来进行数据劫持有什么缺点"></a>使用Object.defineProperty()来进行数据劫持有什么缺点</h3><h3 id="如何保存页面的当前状态"><a href="#如何保存页面的当前状态" class="headerlink" title="如何保存页面的当前状态"></a>如何保存页面的当前状态</h3><h3 id="常见的事件修饰符及其作用"><a href="#常见的事件修饰符及其作用" class="headerlink" title="常见的事件修饰符及其作用"></a>常见的事件修饰符及其作用</h3><h3 id="v-if、v-show、v-html的原理"><a href="#v-if、v-show、v-html的原理" class="headerlink" title="v-if、v-show、v-html的原理"></a>v-if、v-show、v-html的原理</h3><h3 id="对keep-alive的理解，他是如何实现的，具体缓存的是什么"><a href="#对keep-alive的理解，他是如何实现的，具体缓存的是什么" class="headerlink" title="对keep-alive的理解，他是如何实现的，具体缓存的是什么"></a>对keep-alive的理解，他是如何实现的，具体缓存的是什么</h3><h3 id="Vue中封装的数组方法有哪些，其如何实现页面更新"><a href="#Vue中封装的数组方法有哪些，其如何实现页面更新" class="headerlink" title="Vue中封装的数组方法有哪些，其如何实现页面更新"></a>Vue中封装的数组方法有哪些，其如何实现页面更新</h3><h3 id="Vue-template到render的过程"><a href="#Vue-template到render的过程" class="headerlink" title="Vue template到render的过程"></a>Vue template到render的过程</h3><h3 id="Vue-data中某一个属性的值发生改变后视图会立即同步执行重新渲染吗？"><a href="#Vue-data中某一个属性的值发生改变后视图会立即同步执行重新渲染吗？" class="headerlink" title="Vue data中某一个属性的值发生改变后视图会立即同步执行重新渲染吗？"></a>Vue data中某一个属性的值发生改变后视图会立即同步执行重新渲染吗？</h3><h3 id="Vue如何监听对象或数组某个属性的变化"><a href="#Vue如何监听对象或数组某个属性的变化" class="headerlink" title="Vue如何监听对象或数组某个属性的变化"></a>Vue如何监听对象或数组某个属性的变化</h3><h3 id="Vue模板编译原理"><a href="#Vue模板编译原理" class="headerlink" title="Vue模板编译原理"></a>Vue模板编译原理</h3><h3 id="对SSR的理解"><a href="#对SSR的理解" class="headerlink" title="对SSR的理解"></a>对SSR的理解</h3><h3 id="Vue的性能优化有哪些"><a href="#Vue的性能优化有哪些" class="headerlink" title="Vue的性能优化有哪些"></a>Vue的性能优化有哪些</h3><h3 id="MVVM的优缺点"><a href="#MVVM的优缺点" class="headerlink" title="MVVM的优缺点"></a>MVVM的优缺点</h3><h3 id="Vue子组件和父组件的执行顺序"><a href="#Vue子组件和父组件的执行顺序" class="headerlink" title="Vue子组件和父组件的执行顺序"></a>Vue子组件和父组件的执行顺序</h3><h2 id="路由-1"><a href="#路由-1" class="headerlink" title="路由"></a>路由</h2><h3 id="Vue-Router的懒加载如何实现"><a href="#Vue-Router的懒加载如何实现" class="headerlink" title="Vue-Router的懒加载如何实现"></a>Vue-Router的懒加载如何实现</h3><h3 id="如何定义动态路由？如何获取传过来的动态参数"><a href="#如何定义动态路由？如何获取传过来的动态参数" class="headerlink" title="如何定义动态路由？如何获取传过来的动态参数"></a>如何定义动态路由？如何获取传过来的动态参数</h3><h3 id="Vue-Router路由钩子在生命周期的体现"><a href="#Vue-Router路由钩子在生命周期的体现" class="headerlink" title="Vue-Router路由钩子在生命周期的体现"></a>Vue-Router路由钩子在生命周期的体现</h3><h3 id="Vue-Router跳转和location-href有什么区别"><a href="#Vue-Router跳转和location-href有什么区别" class="headerlink" title="Vue-Router跳转和location.href有什么区别"></a>Vue-Router跳转和location.href有什么区别</h3><h3 id="Vue-router导航守卫有哪些"><a href="#Vue-router导航守卫有哪些" class="headerlink" title="Vue-router导航守卫有哪些"></a>Vue-router导航守卫有哪些</h3><h2 id="Vuex-1"><a href="#Vuex-1" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="vuex和localStorage的区别"><a href="#vuex和localStorage的区别" class="headerlink" title="vuex和localStorage的区别"></a>vuex和localStorage的区别</h3><h3 id="为什么要用Vuex"><a href="#为什么要用Vuex" class="headerlink" title="为什么要用Vuex"></a>为什么要用Vuex</h3><h3 id="Vuex有哪几种属性"><a href="#Vuex有哪几种属性" class="headerlink" title="Vuex有哪几种属性"></a>Vuex有哪几种属性</h3><h3 id="为什么Vuex的mutation中不能异步操作"><a href="#为什么Vuex的mutation中不能异步操作" class="headerlink" title="为什么Vuex的mutation中不能异步操作"></a>为什么Vuex的mutation中不能异步操作</h3><h3 id="Vuex和单纯的全局对象有什么区别"><a href="#Vuex和单纯的全局对象有什么区别" class="headerlink" title="Vuex和单纯的全局对象有什么区别"></a>Vuex和单纯的全局对象有什么区别</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zzrjack.github.io">云无月</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zzrjack.github.io/2022/09/17/Vue/">https://zzrjack.github.io/2022/09/17/Vue/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zzrjack.github.io" target="_blank">云无月のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue/">Vue</a><a class="post-meta__tags" href="/tags/%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81/">手撕代码</a></div><div class="post_share"><div class="social-share" data-image="/img/bg1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="next-cover" src="/img/bg1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/%E5%8D%97%E5%AE%AB.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">云无月</div><div class="author-info__description">喜忧参半之人</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zzrjack" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1220939105@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E9%A2%98%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">一级题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">Vue基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">Vue的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">双向数据绑定的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM%EF%BC%8CMVC-MVP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.3.</span> <span class="toc-text">MVVM，MVC,MVP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.4.</span> <span class="toc-text">Computed和watch的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Computed%E5%92%8CMethods%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.5.</span> <span class="toc-text">Computed和Methods区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.6.</span> <span class="toc-text">v-if和v-show的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.7.</span> <span class="toc-text">data为什么是一个函数而不是一个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.8.</span> <span class="toc-text">Vue单页应用和多页应用的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.9.</span> <span class="toc-text">Vue的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9spa%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.10.</span> <span class="toc-text">对spa单页面的理解，它的优缺点分别是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.2.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8Bvue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">简单说下vue的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#created%E5%92%8Cmounted%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.2.</span> <span class="toc-text">created和mounted区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%B7%E6%B1%82%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.3.</span> <span class="toc-text">一般在哪个生命周期请求异步数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keep-alive%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">keep-alive与生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.3.</span> <span class="toc-text">组件通信的方式有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-number">1.4.</span> <span class="toc-text">路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E5%92%8Chistory%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.1.</span> <span class="toc-text">hash和history模式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.4.2.</span> <span class="toc-text">对前端路由的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2hash%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">1.4.3.</span> <span class="toc-text">如何获取页面hash的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#route-router%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.4.</span> <span class="toc-text">$route $router的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#params%E5%92%8Cquery%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.5.</span> <span class="toc-text">params和query的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex"><span class="toc-number">1.5.</span> <span class="toc-text">Vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.5.1.</span> <span class="toc-text">Vuex的原理以及自己的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#action%E5%92%8Cmutation%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.2.</span> <span class="toc-text">action和mutation的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rudex%E5%92%8CVuex%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%96%E4%BB%AC%E5%85%B1%E5%90%8C%E7%9A%84%E6%80%9D%E6%83%B3"><span class="toc-number">1.5.3.</span> <span class="toc-text">Rudex和Vuex的区别，他们共同的思想</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-0"><span class="toc-number">1.6.</span> <span class="toc-text">Vue3.0</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E6%9B%B4%E6%96%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">有什么更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defineProperty%E5%92%8Cproxy%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.2.</span> <span class="toc-text">defineProperty和proxy的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%883-0%E8%A6%81%E7%94%A8proxy"><span class="toc-number">1.6.3.</span> <span class="toc-text">为什么3.0要用proxy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">1.7.</span> <span class="toc-text">虚拟DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%99%9A%E6%8B%9FDom%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.7.1.</span> <span class="toc-text">对虚拟Dom的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DIFF%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">DIFF算法的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E4%B8%ADKey%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.7.3.</span> <span class="toc-text">Vue中Key的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AEindex%E4%BD%9C%E4%B8%BAKey"><span class="toc-number">1.7.4.</span> <span class="toc-text">为什么不建议index作为Key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E7%9C%9F%E7%9A%84%E6%AF%94%E7%9C%9F%E5%AE%9EDOM%E6%80%A7%E8%83%BD%E5%A5%BD%E5%90%97"><span class="toc-number">1.7.5.</span> <span class="toc-text">虚拟DOM真的比真实DOM性能好吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">1.7.6.</span> <span class="toc-text">虚拟DOM解析过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E9%A2%98%E7%9B%AE"><span class="toc-number">2.</span> <span class="toc-text">二级题目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%9F%BA%E7%A1%80"><span class="toc-number">2.1.</span> <span class="toc-text">vue基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Object-defineProperty-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">使用Object.defineProperty()来进行数据劫持有什么缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">如何保存页面的当前状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">常见的事件修饰符及其作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if%E3%80%81v-show%E3%80%81v-html%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.4.</span> <span class="toc-text">v-if、v-show、v-html的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BB%96%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E5%85%B7%E4%BD%93%E7%BC%93%E5%AD%98%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.5.</span> <span class="toc-text">对keep-alive的理解，他是如何实现的，具体缓存的是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E4%B8%AD%E5%B0%81%E8%A3%85%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%85%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E6%9B%B4%E6%96%B0"><span class="toc-number">2.1.6.</span> <span class="toc-text">Vue中封装的数组方法有哪些，其如何实现页面更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-template%E5%88%B0render%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.7.</span> <span class="toc-text">Vue template到render的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-data%E4%B8%AD%E6%9F%90%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E5%8F%91%E7%94%9F%E6%94%B9%E5%8F%98%E5%90%8E%E8%A7%86%E5%9B%BE%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E5%90%97%EF%BC%9F"><span class="toc-number">2.1.8.</span> <span class="toc-text">Vue data中某一个属性的值发生改变后视图会立即同步执行重新渲染吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E6%88%96%E6%95%B0%E7%BB%84%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">2.1.9.</span> <span class="toc-text">Vue如何监听对象或数组某个属性的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.10.</span> <span class="toc-text">Vue模板编译原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9SSR%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.1.11.</span> <span class="toc-text">对SSR的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.1.12.</span> <span class="toc-text">Vue的性能优化有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.13.</span> <span class="toc-text">MVVM的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue%E5%AD%90%E7%BB%84%E4%BB%B6%E5%92%8C%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.1.14.</span> <span class="toc-text">Vue子组件和父组件的执行顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1-1"><span class="toc-number">2.2.</span> <span class="toc-text">路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-Router%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.1.</span> <span class="toc-text">Vue-Router的懒加载如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%EF%BC%9F%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%BC%A0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">如何定义动态路由？如何获取传过来的动态参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-Router%E8%B7%AF%E7%94%B1%E9%92%A9%E5%AD%90%E5%9C%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">Vue-Router路由钩子在生命周期的体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-Router%E8%B7%B3%E8%BD%AC%E5%92%8Clocation-href%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.4.</span> <span class="toc-text">Vue-Router跳转和location.href有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-router%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.2.5.</span> <span class="toc-text">Vue-router导航守卫有哪些</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-1"><span class="toc-number">2.3.</span> <span class="toc-text">Vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex%E5%92%8ClocalStorage%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.1.</span> <span class="toc-text">vuex和localStorage的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Vuex"><span class="toc-number">2.3.2.</span> <span class="toc-text">为什么要用Vuex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B1%9E%E6%80%A7"><span class="toc-number">2.3.3.</span> <span class="toc-text">Vuex有哪几种属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Vuex%E7%9A%84mutation%E4%B8%AD%E4%B8%8D%E8%83%BD%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.4.</span> <span class="toc-text">为什么Vuex的mutation中不能异步操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex%E5%92%8C%E5%8D%95%E7%BA%AF%E7%9A%84%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.5.</span> <span class="toc-text">Vuex和单纯的全局对象有什么区别</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/17/Vue/" title="Vue"><img src="/img/bg1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue"/></a><div class="content"><a class="title" href="/2022/09/17/Vue/" title="Vue">Vue</a><time datetime="2022-09-17T03:45:42.000Z" title="发表于 2022-09-17 11:45:42">2022-09-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="/img/bg1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2022/09/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2022-09-16T07:37:16.000Z" title="发表于 2022-09-16 15:37:16">2022-09-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" title="每一个不曾起舞的日子，都是对生命的辜负。"><img src="/img/bg1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="每一个不曾起舞的日子，都是对生命的辜负。"/></a><div class="content"><a class="title" href="/2022/09/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" title="每一个不曾起舞的日子，都是对生命的辜负。">每一个不曾起舞的日子，都是对生命的辜负。</a><time datetime="2022-09-15T14:57:53.000Z" title="发表于 2022-09-15 22:57:53">2022-09-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/bg1.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 云无月</div><div class="footer_custom_text">欢迎来到云无月の <a href="https://zzrjack.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HIRU9WxWExQfPi2OgFnhxbbw-gzGzoHsz',
      appKey: 'FFQd7tJuaOqPoRSb36xW6qBX',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="7638948053" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script src="/js/sakura.js" defer></script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0" defer></script><script src="/js/weather.js" defer></script><script src="https://cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js" defer></script><script src="/js/title.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>